#! /usr/bin/perl -w

use strict;
use warnings;
use Getopt::Long;
use Cwd 'abs_path';
my $abs_path = abs_path(__FILE__);
my @tmp = split(/\//, $abs_path);
pop(@tmp);
$abs_path = join("/", @tmp);

sub check_outDir($);
sub check_bed($);
sub check_for_bwa();
sub check_bwa_index($);
sub check_for_fasta_twobit($);
sub check_for_samtools();
sub get_intervalList($$);
sub check_for_R();


sub run_blacklist($$$$$$$$$$);
sub run_calcErrorRates($$$$$$$$);
sub get_sub_type($$);
sub mean_and_stdev(@);

my $usage = "\nUse:\n\tMutascope runPipeline [-bed BED] [-fasta FA] [-dbsnp VCF] [-pdir PATH] [-normal STRING] [-tumor STRING] [-nr1_fastq FASTQ] [-nr2_fastq FASTQ] [-tr1_fastq FASTQ] [-tr2_fastq FASTQ] [-BQ INT] [-MQ INT] [-saaf FLOAT] [-gaaf INT] [-mcovs INT,FLOAT] [-e FLOAT] [-het FLOAT] [-length INT] [-t INT] [-dist INT] [-strand_specific TRUE/FALSE] [-bwa_path FILE] [-samtools_path FILE] [-noBlacklist] [-useTumorErrors] [-h]

Description:
\trunPipeline runs the full Mutascope pipeline from start to finish.  It begins by aligning the normal and tumor reads. Next it refines the BAMS and realigns the reads together. Next it generates the xpileup file and error rate files needed to call variants.  Finally it calls variants and applies the standard Mutascope filters.  If the 'blacklist' file is not already generated by Mutascope it will generate that file once (BED_name.blacklist). See the manual for more detail.

Note:
\tMutascope requires that R is installed!

Example:
\tMutascope runPipeline -bed BED_NAME.bed -fasta hg19.fa -dbsnp dbsnp131.vcf -pdir /home/projects/patient1/ -normal patient1Normal -tumor patient1Tumor -nr1_fastq patient1Normal_read1.fastq -nr2_fastq patient1Normal_read2.fastq -tr1_fastq patient1Tumor_read1.fastq -tr2_fastq patient1Tumor_read2.fastq -strand_specific TRUE -t 10

Options:
\t-bed\t\tBED\tBED format file containing target locations with primer locations (See BED format in the Manual.pdf for more detail) [REQUIRED]
\t-fasta\t\tFA\tFASTA file of reference genome [REQUIRED]
\t-dbsnp\t\tVCF\tdbSNP file in VCF format [REQUIRED]
\t-pdir\t\tPATH\tPath to the PROJECT directory [REQUIRED]
\t-normal\t\tSTRING\tName of the NORMAL sample (only use letters or numbers! No symbols!) [REQUIRED]
\t-tumor\t\tSTRING\tName of the TUMOR sample (only use letters or numbers! No symbols!) [REQUIRED]
\t-nr1_fastq\tFASTQ\tRead1 FASTQ file for the Normal sample [REQUIRED]
\t-nr2_fastq\tFASTQ\tRead2 FASTQ file for the Normal sample [REQUIRED]
\t-tr1_fastq\tFASTQ\tRead1 FASTQ file for the Tumor sample [REQUIRED]
\t-tr2_fastq\tFASTQ\tRead2 FASTQ file for the Tumor sample [REQUIRED]
\t-BQ\t\tINT\tMinimum Base Quality score (default 10) [Optional]
\t-MQ\t\tINT\tMinimum Mapping Quality score (default 1) [Optional]
\t-saaf\t\tFLOAT\tMinimum Percent of reads in the TUMOR sample with the alternate allele for calling Somatic variants (default 0.5) [Optional]
\t-gaaf\t\tINT\tMinimum Percent of reads in the NORMAL sample with the alternate allele for calling Germline variants (default 15) [Optional]
\t-mcovs\t\tINT,FLOAT\tThe minimum coverage and lower coverage percentile used to calculate the minimum coverage to call variants, whichever is greater (default 10,0.5) [Optional]
\t-e\t\tFLOAT\tDefault error rate (default 0.005) [Optional]
\t-het\t\tFLOAT\tProbability of germline SNP. Prior in Bayesian test (default 0.001) [Optional]
\t-length\t\tINT\tLength of sequencing reads for the preparation of the BlackList file (default 151) [Optional]
\t-t\t\tINT\tNumber of threads for BWA (default 1) [Optional]
\t-dist\t\tINT\tRead vs Amplicon start or stop alignment offset, in nucleotides (default 2) [Optional]
\t-strand_specific\tTRUE/FALSE\tReads are strand specific e.g. all read1 align on the same strand. (default FALSE) [Optional]
\t-bwa_path\tFILE\tBWA executable (full path) [Optional]
\t-samtools_path\tFILE\tSAMTools executable (full path) [Optional]
\t-noBlacklist\tFLAG\tSpecifies to not use/generate the blacklist file [Optional]
\t-useTumorErrors\tFLAG\tSpecifies to use the Tumor error rates when calling Somatic Variants [Optional]
\t-h\t\tFLAG to output help message [Optional]
\n";

my $bed;
my $fasta;
my $dbsnp;
my $pdir;
my $tumor;
my $normal;
my $bwa_path;
my $samtools_path;
my $nr1_fastq;
my $nr2_fastq;
my $tr1_fastq;
my $tr2_fastq;
my $BQ = 10;
my $MQ = 1;
my $saaf = 0.5;
my $mcovs;
my $min_cov = 10;
my $min_perc_cov = 0.5;
my $gaaf = 10;
my $e = 0.005;
my $het = 0.001;
my $length = 151;
my $n1=15;
my $n2=100;
my $t=1;
my $z = 5;
my $s = 5;
my $dist = 2;
my $strand_specific = "FALSE";
my $noBlacklist;
my $useTumorErrors;
my $h;

GetOptions("bed=s" => \$bed,
						"fasta=s" => \$fasta,
						"dbsnp=s" => \$dbsnp,
						"pdir=s" => \$pdir,
						"normal=s" => \$normal,
						"tumor=s" => \$tumor,
						"bwa_path=s" => \$bwa_path,
						"samtools_path=s" => \$samtools_path,
						"nr1_fastq=s" => \$nr1_fastq,
						"nr2_fastq=s" => \$nr2_fastq,
						"tr1_fastq=s" => \$tr1_fastq,
						"tr2_fastq=s" => \$tr2_fastq,
						"BQ=i" => \$BQ,
						"MQ=i" => \$MQ,
						"saaf=f" => \$saaf,
						"mcovs=s" => \$mcovs,
						"gaaf=f" => \$gaaf,
						"e=i" => \$e,
						"het=i" => \$het,
						"length=i" => \$length,
						"t=i" => \$t,
						"z=i" => \$z,
						"s=i" => \$s,
						"dist=i" => \$dist,
						"strand_specific=s" => \$strand_specific,
						"noBlacklist" => \$noBlacklist,
						"useTumorErrors" => \$useTumorErrors,
						"h" => \$h);


die "$usage" if($h);
die "\n$usage\nERROR: Must provide BED file!\n\n" if(!$bed);
die "\n$usage\nERROR: Bed file \"$bed\" doesn't exist!\n\n" if(!(-e $bed));
die "\n$usage\nERROR: Must provide FASTA file!\n\n" if(!$fasta);
die "\n$usage\nERROR: Fasta file \"$fasta\" doesn't exist!\n\n" if(!(-e $fasta));
die "\n$usage\nERROR: Must provide dbSNP file!\n\n" if(!$dbsnp);
die "\n$usage\nERROR: dbSNP file \"$dbsnp\" doesn't exist!\n\n" if(!(-e $dbsnp));
die "\n$usage\nERROR: Must provide a dbSNP file in VCF format!\n\n" if(!($dbsnp =~ m/\.vcf/));
die "\n$usage\nERROR: Must provide the full path to the Output Directory!\n\n" if(!$pdir);
die "\n$usage\nERROR: The Directory \"$pdir\" doesn't exists!\n\n" if(!(-d $pdir));
die "\n$usage\nERROR: Please Specify the name of the normal sample. This should be consistant with all Mutascope scripts (i.e. use the same name for the same sample each time you run Mutascope).\n\n" if(!$normal);
die "\n$usage\nERROR: Please Specify the name of the tumor sample. This should be consistant with all Mutascope scripts (i.e. use the same name for the same sample each time you run Mutascope).\n\n" if(!$tumor);
die "\n$usage\nERROR: The normal sample name can NOT have a '_' in the name.  Please use a different sample name other than \"$normal\".\n\n" if($normal =~ m/_/);
die "\n$usage\nERROR: The tumor sample name can NOT have a '_' in the name.  Please use a different sample name other than \"$tumor\".\n\n" if($tumor =~ m/_/);
die "\n$usage\nERROR: FASTQ file \"$nr1_fastq\" for nr1_fastq doesn't exists!\n\n" if(!$nr1_fastq or !(-e $nr1_fastq));
die "\n$usage\nERROR: FASTQ file \"$nr2_fastq\" for nr2_fastq doesn't exists!\n\n" if(!$nr2_fastq or !(-e $nr2_fastq));
die "\n$usage\nERROR: FASTQ file \"$tr1_fastq\" for tr1_fastq doesn't exists!\n\n" if(!$tr1_fastq or !(-e $tr1_fastq));
die "\n$usage\nERROR: FASTQ file \"$tr2_fastq\" for tr2_fastq doesn't exists!\n\n" if(!$tr2_fastq or !(-e $tr2_fastq));

if($mcovs){
	die "\n$usage\nERROR: mcovs format is NOT correct. Must be in the INT,FLOAT format!\n\n" if(!($mcovs =~ m/\d+,(\d+|\.)/));
	($min_cov, $min_perc_cov) = split(/,/, $mcovs);
}
$min_perc_cov = $min_perc_cov/100;


check_outDir($pdir);
check_bed($bed);
check_for_R();
check_bwa_index($fasta);

if(!$bwa_path){
	$bwa_path = check_for_bwa();
}else{
	die "\n$usage\nERROR: BWA: \"$bwa_path\" doesn't exists!\n\n" if(!(-e $bwa_path));
}
print STDERR "Using bwa: $bwa_path\n\n";

if(!$samtools_path){
	$samtools_path = check_for_samtools();
}else{
	die "\n$usage\nERROR: SAMTools: \"$samtools_path\" doesn't exists!\n\n" if(!(-e $samtools_path));
}
print STDERR "Using SAMTools: $samtools_path\n\n";


my $interval_list = get_intervalList($bed, $pdir);
my $fasta_2bit = check_for_fasta_twobit($fasta);
my @tmps = split(/\//, $bed);
my $bed_name = "$pdir\/intermediate/".$tmps[$#tmps];
$bed_name =~ s/.bed//;



#Run blackList if the file doesn't exists
if(!(-e "$bed_name.blacklist") and !$noBlacklist){
	run_blacklist($abs_path, $length, $bed, $fasta_2bit, $bed_name, $n1, $t, $fasta, $n2, $bwa_path);
}


# Align Reads
`$bwa_path bwasw -z $z -t $t -s $s $fasta $nr1_fastq | $samtools_path view -Shb - > $pdir\/intermediate/$normal\_read1_bwaSWAln.bam`;
`$bwa_path bwasw -z $z -t $t -s $s $fasta $nr2_fastq | $samtools_path view -Shb - > $pdir\/intermediate/$normal\_read2_bwaSWAln.bam`;

`$bwa_path bwasw -z $z -t $t -s $s $fasta $tr1_fastq | $samtools_path view -Shb - > $pdir\/intermediate/$tumor\_read1_bwaSWAln.bam`;
`$bwa_path bwasw -z $z -t $t -s $s $fasta $tr2_fastq | $samtools_path view -Shb - > $pdir\/intermediate/$tumor\_read2_bwaSWAln.bam`;



# Refign Alignment
open(OUT, ">$pdir\/quality/$normal\_alignment_stats.txt");
print OUT "";
close(OUT);

`$samtools_path view -h $pdir\/intermediate/$normal\_read1_bwaSWAln.bam | perl $abs_path/remove_multiAligned_reads.pl -read R1 - $pdir\/quality/$normal\_alignment_stats.txt | perl $abs_path/filter_SAM_on_SW_score.pl -read R1 - $pdir\/quality/$normal\_alignment_stats.txt | perl $abs_path/add_readGroup_to_SAM_and_filter.pl -sample $normal -read R1 -dist $dist -strand_specific $strand_specific $bed - $pdir\/quality/$normal\_alignment_stats.txt | $samtools_path view -Sbh - | $samtools_path sort - $pdir\/intermediate/$normal\_read1_mapped_filteredSW_rgAddedFilt_sorted`;

`$samtools_path view -h $pdir\/intermediate/$normal\_read2_bwaSWAln.bam | perl $abs_path/remove_multiAligned_reads.pl -read R2 - $pdir\/quality/$normal\_alignment_stats.txt | perl $abs_path/filter_SAM_on_SW_score.pl -read R2 - $pdir\/quality/$normal\_alignment_stats.txt | perl $abs_path/add_readGroup_to_SAM_and_filter.pl -sample $normal -read R2 -dist $dist -strand_specific $strand_specific $bed - $pdir\/quality/$normal\_alignment_stats.txt | $samtools_path view -Sbh - | $samtools_path sort - $pdir\/intermediate/$normal\_read2_mapped_filteredSW_rgAddedFilt_sorted`;

`mkdir $pdir/intermediate/$$/`;
`java -Xmx2048M -Djava.io.tmpdir=$pdir/intermediate/$$/ -jar $abs_path/MergeSamFiles.jar I=$pdir\/intermediate/$normal\_read1_mapped_filteredSW_rgAddedFilt_sorted.bam I=$pdir\/intermediate/$normal\_read2_mapped_filteredSW_rgAddedFilt_sorted.bam O=$pdir\/intermediate/$normal\_merged.bam AS=TRUE USE_THREADING=TRUE`;
`rm -rf $pdir/intermediate/$$`;

`$samtools_path view -h $pdir\/intermediate/$normal\_merged.bam | perl $abs_path/remove_softClipping.pl - | $samtools_path view -Shb - | $samtools_path sort - $pdir\/intermediate/$normal\_merged_unClipped`;

`$samtools_path view -h $pdir\/intermediate/$normal\_merged_unClipped.bam | perl $abs_path/clip_primers_from_bam.pl $bed - | $samtools_path view -Sbh - | $samtools_path sort - $pdir\/intermediate/$normal\_merged_unClipped_primersClipped`;

`$samtools_path index $pdir\/intermediate/$normal\_merged_unClipped_primersClipped.bam`;

`$samtools_path view -h $pdir\/intermediate/$normal\_merged_unClipped_primersClipped.bam | perl $abs_path/calculate_bedReadCounts.pl $bed - > $pdir\/quality/$normal\_readsPerAmplicon.txt`;

`R --slave --args $pdir\/quality/$normal\_readsPerAmplicon.txt $pdir\/quality/$normal\_readsPerAmplicon_meanSD.txt $pdir\/quality/$normal\_readsPerAmplicon_cov2X.txt $pdir\/quality/$normal\_readsPerAmplicon_sensitivity.txt $pdir\/quality/$normal\_readsPerAmplicon_cumulativeCoverageDist.pdf < $abs_path/read_cov_rcode.r`;


open(OUT, ">$pdir\/quality/$tumor\_alignment_stats.txt");
print OUT "";
close(OUT);

`$samtools_path view -h $pdir\/intermediate/$tumor\_read1_bwaSWAln.bam | perl $abs_path/remove_multiAligned_reads.pl -read R1 - $pdir\/quality/$tumor\_alignment_stats.txt | perl $abs_path/filter_SAM_on_SW_score.pl -read R1 - $pdir\/quality/$tumor\_alignment_stats.txt | perl $abs_path/add_readGroup_to_SAM_and_filter.pl -sample $tumor -read R1 -dist $dist -strand_specific $strand_specific $bed - $pdir\/quality/$tumor\_alignment_stats.txt | $samtools_path view -Sbh - | $samtools_path sort - $pdir\/intermediate/$tumor\_read1_mapped_filteredSW_rgAddedFilt_sorted`;

`$samtools_path view -h $pdir\/intermediate/$tumor\_read2_bwaSWAln.bam | perl $abs_path/remove_multiAligned_reads.pl -read R2 - $pdir\/quality/$tumor\_alignment_stats.txt | perl $abs_path/filter_SAM_on_SW_score.pl -read R2 - $pdir\/quality/$tumor\_alignment_stats.txt | perl $abs_path/add_readGroup_to_SAM_and_filter.pl -sample $tumor -read R2 -dist $dist -strand_specific $strand_specific $bed - $pdir\/quality/$tumor\_alignment_stats.txt | $samtools_path view -Sbh - | $samtools_path sort - $pdir\/intermediate/$tumor\_read2_mapped_filteredSW_rgAddedFilt_sorted`;

`mkdir $pdir/intermediate/$$/`;
`java -Xmx2048M -Djava.io.tmpdir=$pdir/intermediate/$$/ -jar $abs_path/MergeSamFiles.jar I=$pdir\/intermediate/$tumor\_read1_mapped_filteredSW_rgAddedFilt_sorted.bam I=$pdir\/intermediate/$tumor\_read2_mapped_filteredSW_rgAddedFilt_sorted.bam O=$pdir\/intermediate/$tumor\_merged.bam AS=TRUE USE_THREADING=TRUE`;
`rm -rf $pdir/intermediate/$$`;

`$samtools_path view -h $pdir\/intermediate/$tumor\_merged.bam | perl $abs_path/remove_softClipping.pl - | $samtools_path view -Shb - | $samtools_path sort - $pdir\/intermediate/$tumor\_merged_unClipped`;

`$samtools_path view -h $pdir\/intermediate/$tumor\_merged_unClipped.bam | perl $abs_path/clip_primers_from_bam.pl $bed - | $samtools_path view -Sbh - | $samtools_path sort - $pdir\/intermediate/$tumor\_merged_unClipped_primersClipped`;

`$samtools_path index $pdir\/intermediate/$tumor\_merged_unClipped_primersClipped.bam`;

`$samtools_path view -h $pdir\/intermediate/$tumor\_merged_unClipped_primersClipped.bam | perl $abs_path/calculate_bedReadCounts.pl $bed - > $pdir\/quality/$tumor\_readsPerAmplicon.txt`;

`R --slave --args $pdir\/quality/$tumor\_readsPerAmplicon.txt $pdir\/quality/$tumor\_readsPerAmplicon_meanSD.txt $pdir\/quality/$tumor\_readsPerAmplicon_cov2X.txt $pdir\/quality/$tumor\_readsPerAmplicon_sensitivity.txt $pdir\/quality/$tumor\_readsPerAmplicon_cumulativeCoverageDist.pdf < $abs_path/read_cov_rcode.r`;


#group Realign
`$samtools_path view -H $pdir\/intermediate/$normal\_merged_unClipped_primersClipped.bam | perl $abs_path/get_readGroups.pl - > $pdir\/intermediate/$normal\_readGroups.txt`;
`$samtools_path view -H $pdir\/intermediate/$tumor\_merged_unClipped_primersClipped.bam | perl $abs_path/get_readGroups.pl - > $pdir\/intermediate/$tumor\_readGroups.txt`;

`mkdir $pdir/intermediate/$$/`;
`java -Xmx2048M -Djava.io.tmpdir=$pdir/intermediate/$$/ -jar $abs_path/MergeSamFiles.jar INPUT=$pdir\/intermediate/$normal\_merged_unClipped_primersClipped.bam INPUT=$pdir\/intermediate/$tumor\_merged_unClipped_primersClipped.bam OUTPUT=$pdir\/intermediate/$normal\_$tumor.bam ASSUME_SORTED=TRUE USE_THREADING=TRUE `;
`$samtools_path index $pdir\/intermediate/$normal\_$tumor.bam`;

`java -Xmx8G -Djava.io.tmpdir=$pdir/intermediate/$$/ -jar $abs_path/GenomeAnalysisTK.jar -T IndelRealigner --targetIntervals $interval_list -I $pdir\/intermediate/$normal\_$tumor.bam -R $fasta --out $pdir\/intermediate/$normal\_$tumor\_realigned.bam -maxInMemory 300000 --maxReadsForRealignment 500000 --LODThresholdForCleaning 2.5 --maxConsensuses 60 --maxReadsForConsensuses 240`;
`rm -rf $pdir/intermediate/$$`;

`$samtools_path view -bhR $pdir\/intermediate/$normal\_readGroups.txt $pdir\/intermediate/$normal\_$tumor\_realigned.bam > $pdir\/intermediate/$normal\_merged_unClipped_primersClipped_realigned.bam`;
`$samtools_path index $pdir\/intermediate/$normal\_merged_unClipped_primersClipped_realigned.bam`;

`$samtools_path view -bhR $pdir\/intermediate/$tumor\_readGroups.txt $pdir\/intermediate/$normal\_$tumor\_realigned.bam > $pdir\/intermediate/$tumor\_merged_unClipped_primersClipped_realigned.bam`;
`$samtools_path index $pdir\/intermediate/$tumor\_merged_unClipped_primersClipped_realigned.bam`;


#xpileup 
`$samtools_path view -h $pdir/intermediate/$normal\_merged_unClipped_primersClipped_realigned.bam | perl $abs_path/make_xpileup_file.pl -bed $bed -fasta $fasta -pdir $pdir -samtools $samtools_path - `;
`$samtools_path view -h $pdir/intermediate/$tumor\_merged_unClipped_primersClipped_realigned.bam | perl $abs_path/make_xpileup_file.pl -bed $bed -fasta $fasta -pdir $pdir -samtools $samtools_path - `;

#calculate Error Rates
my $error_rates;
if(!$useTumorErrors){
	run_calcErrorRates($bed, $dbsnp, $noBlacklist, "$bed_name.blacklist", $pdir, $normal, $BQ, $MQ);
	$error_rates = "$pdir\/intermediate/$normal.errorRates";
}else{
	run_calcErrorRates($bed, $dbsnp, $noBlacklist, "$bed_name.blacklist", $pdir, $tumor, $BQ, $MQ) if($useTumorErrors);
	$error_rates = "$pdir\/intermediate/$tumor.errorRates";
}

#call somatic
`perl $abs_path/somatic_caller.pl -BQ $BQ -MQ $MQ -twoBit $fasta_2bit -gaaf $gaaf -min_perc_cov $min_perc_cov -het $het -e $e -saaf $saaf -min_cov $min_cov -pdir $pdir -normal $normal -tumor $tumor -bed $bed -error_rates $error_rates -blacklist $bed_name.blacklist -dbsnp $dbsnp -nxpileup $pdir\/intermediate/$normal.xpileup -txpileup $pdir\/intermediate/$tumor.xpileup > $pdir\/results/$normal\_vs_$tumor.vcf` if(!$noBlacklist);

`perl $abs_path/somatic_caller.pl -BQ $BQ -MQ $MQ -twoBit $fasta_2bit -gaaf $gaaf -min_perc_cov $min_perc_cov -het $het -e $e -saaf $saaf -min_cov $min_cov -pdir $pdir -normal $normal -tumor $tumor -bed $bed -error_rates $error_rates -noBlacklist -dbsnp $dbsnp -nxpileup $pdir\/intermediate/$normal.xpileup -txpileup $pdir\/intermediate/$tumor.xpileup > $pdir\/results/$normal\_vs_$tumor.vcf` if($noBlacklist);

`gzip $pdir\/intermediate/$normal.xpileup`;
`gzip $pdir\/intermediate/$tumor.xpileup`;

`perl $abs_path/filter_tumorNormal_vcf.pl -vcf $pdir\/results/$normal\_vs_$tumor.vcf > $pdir\/results/$normal\_vs_$tumor\_filtered.vcf`;

`perl $abs_path/generate_info_for_TNPlot.pl $pdir\/results/$normal\_vs_$tumor\_filtered.vcf $pdir\/intermediate/$normal\_vs_$tumor\_filtered_plotInfo.txt`;

`R --slave --args $pdir\/intermediate/$normal\_vs_$tumor\_filtered_plotInfo.txt $pdir\/quality/$normal\_vs_$tumor\_filtered_variantPlot.pdf < $abs_path/variant_QC_plot.r`;

`perl $abs_path/make_logR_file.pl $pdir\/quality/$normal\_readsPerAmplicon.txt $pdir\/quality/$tumor\_readsPerAmplicon.txt > $pdir\/results/$normal\_vs_$tumor\_ampliconLogR.txt`;

####  REMOVE FILES AFTER FINISHED #####
`rm $pdir\/intermediate/$normal\_vs_$tumor\_filtered_plotInfo.txt`;

`rm $pdir\/intermediate/$normal\_read2_bwaSWAln.bam`;
`rm $pdir\/intermediate/$tumor\_read2_bwaSWAln.bam`;
`rm $pdir\/intermediate/$normal\_read1_bwaSWAln.bam`;
`rm $pdir\/intermediate/$tumor\_read1_bwaSWAln.bam`;

`rm $pdir\/intermediate/$normal\_read1_mapped_filteredSW_rgAddedFilt_sorted.bam`; 
`rm $pdir\/intermediate/$normal\_read2_mapped_filteredSW_rgAddedFilt_sorted.bam`; 
`rm $pdir\/intermediate/$normal\_merged_unClipped.bam`;
`rm $pdir\/intermediate/$normal\_merged.bam`;
`rm $pdir\/intermediate/$normal\_merged_unClipped_primersClipped.bam`;
`rm $pdir\/intermediate/$normal\_merged_unClipped_primersClipped.bam.bai`;
`rm $pdir\/intermediate/$tumor\_read1_mapped_filteredSW_rgAddedFilt_sorted.bam`; 
`rm $pdir\/intermediate/$tumor\_read2_mapped_filteredSW_rgAddedFilt_sorted.bam`; 
`rm $pdir\/intermediate/$tumor\_merged_unClipped.bam`;
`rm $pdir\/intermediate/$tumor\_merged.bam`;
`rm $pdir\/intermediate/$tumor\_merged_unClipped_primersClipped.bam`;
`rm $pdir\/intermediate/$tumor\_merged_unClipped_primersClipped.bam.bai`;

`rm $pdir\/intermediate/$normal\_readGroups.txt`;
`rm $pdir\/intermediate/$tumor\_readGroups.txt`;
`rm $pdir\/intermediate/$normal\_$tumor.bam`;
`rm $pdir\/intermediate/$normal\_$tumor.bam.bai`;
`rm $pdir\/intermediate/$normal\_$tumor\_realigned.bam`;
`rm $pdir\/intermediate/$normal\_$tumor\_realigned.bai`;

`rm $pdir\/results/$normal\_vs_$tumor.vcf`;






sub get_intervalList($$){
	my ($bed, $pdir) = @_;
	
	my @tmps = split(/\//, $bed);
	my $interval_list = "$pdir\/intermediate/".$tmps[$#tmps];
	$interval_list =~ s/.bed//;
	$interval_list .= ".interval_list";
	
	if(-e $interval_list){
		return ($interval_list);
	}else{
		`perl $abs_path/make_intervalList_from_BED.pl $bed > $interval_list`;
		return ($interval_list);
	}
}



sub check_for_fasta_twobit($){
	my ($f) = @_;
	$f =~ s/.fa//;
	die "\nERROR: The FASTA 2bit file '$f.2bit' must be in the same folder as the $f.fa file!!!\n\nTo generate the 2bit file run the command: $abs_path/scripts/faToTwoBit -noMask $f.fa $f.2bit\n\n" if(!(-e "$f.2bit"));
	return("$f.2bit");
}

sub check_outDir($){
	my ($od) = @_;
	if(!(-d "$od/results")){
		`mkdir $od/results`;
		print STDERR "Making \"$od/results\" directory!\n\n";
	}
	if(!(-d "$od/intermediate")){
		`mkdir $od/intermediate`;
		print STDERR "Making \"$od/intermediate\" directory!\n\n";
	}
	if(!(-d "$od/quality")){
		`mkdir $od/quality`;
		print STDERR "Making \"$od/quality\" directory!\n\n";
	}
}


sub check_bed($){
	my ($bed) = @_;
	open(BED, $bed);
	while(my $line = <BED>){
		chomp $line;
		next if($line =~ m/^track/);
		next if($line =~ m/^#/);
		next if($line =~ m/^>/);
		
		my ($chr, $start, $stop, $name, $score, $strand, $pstart, $pstop, @other) = split(/\t/, $line);
		die "The BED line \"$line\" is not the proper format!\nSee the Manual.pdf for BED format details.\n\n" if(!$pstart);
		die "The BED line \"$line\" is not the proper format!\nSee the Manual.pdf for BED format details.\n\n" if(!$pstop);
		die "The BED line \"$line\" is not the proper format!\nSee the Manual.pdf for BED format details.\n\n" if(!$start);
		die "The BED line \"$line\" is not the proper format!\nSee the Manual.pdf for BED format details.\n\n" if(!$stop);
		die "The BED line \"$line\" is not the proper format!\nSee the Manual.pdf for BED format details.\n\n" if($start > $pstart);
		die "The BED line \"$line\" is not the proper format!\nSee the Manual.pdf for BED format details.\n\n" if($stop < $pstop);
		die "The BED line \"$line\" is not the proper format!\nSee the Manual.pdf for BED format details.\n\n" if($pstart > $pstop);
		die "The BED line \"$line\" is not the proper format!\nSee the Manual.pdf for BED format details.\n\n" if($start > $stop);
		
	}
	close(BED);
}

sub check_for_R(){
	my $r_result = `which R`;
	chomp $r_result;
	if($r_result eq ""){
		die "ERROR: Can NOT find R.  You need to install R before running this script! See http://www.r-project.org/\n";
	}
}



sub check_for_bwa(){
	my $bwa_result = `which bwa`;
	chomp $bwa_result;
	if($bwa_result eq ""){
		die "\nERROR: Can not find BWA. Please install BWA (http://bio-bwa.sourceforge.net/).\n   If installed either specify the path (-bwa_path) or create a link to your local path (Example: /usr/bin/).\n"; 
	}else{
		return $bwa_result;
	}
}



sub check_bwa_index($){
	my ($fasta) = @_;
	my $index_flag = 0;
	my $missing = "";
	if(!(-e "$fasta.amb")){
		$index_flag = 1;
		$missing = "$fasta.amb";
	}elsif(!(-e "$fasta.ann")){
		$index_flag = 1;
		$missing = "$fasta.ann";
	}elsif(!(-e "$fasta.bwt")){
		$index_flag = 1;
		$missing = "$fasta.bwt";
	}elsif(!(-e "$fasta.pac")){
		$index_flag = 1;
		$missing = "$fasta.pac";
	}elsif(!(-e "$fasta.sa")){
		$index_flag = 1;
		$missing = "$fasta.sa";
	}
	
	if($index_flag == 1){
		die "\nERROR:\tThe fasta file \"$fasta\" is not indexed properly by BWA. You are missing the \"$missing\" file\n\nPlease index the fasta file with bwa! Run: bwa index -a bwtsw $fasta\n\n";
		#`bwa index -a bwtsw $fasta`;
		
	}
}



sub check_for_samtools(){
	my $samtools_results = `which samtools`;
	chomp $samtools_results;
	if($samtools_results eq ""){
		die "\nERROR: Can not find SAMTools. Please install SAMTools (http://samtools.sourceforge.net/).\n   If installed either specify the path (-samtools_path) or create a link to your local path (Example: /usr/bin/).\n"; 
	}else{
		return $samtools_results;
	}
}




sub run_blacklist($$$$$$$$$$){
	my ($abs_path, $length, $bed, $fasta_2bit, $bed_name, $n1, $t, $fasta, $n2, $bwa_path) = @_;
	`perl $abs_path/bed_to_fastq.pl -length $length -bed $bed -twoBit $fasta_2bit -sub_name $bed_name`;

	`$bwa_path aln -N -n $n1 -t $t $fasta $bed_name\_Forward_reads.fastq > $bed_name\_forward.sai`;
	`$bwa_path samse -n $n2 $fasta $bed_name\_forward.sai $bed_name\_Forward_reads.fastq > $bed_name\_Forward_reads_aligned.sam`;
	`$bwa_path aln -N -n $n1 -t $t $fasta $bed_name\_Reverse_reads.fastq > $bed_name\_reverse.sai`;
	`$bwa_path samse -n $n2 $fasta $bed_name\_reverse.sai $bed_name\_Reverse_reads.fastq > $bed_name\_Reverse_reads_aligned.sam`;

	`perl $abs_path/create_altAlignment_matrix_file.pl -twoBit $fasta_2bit $bed_name\_Forward_reads_aligned.sam $pdir > $bed_name\_Forward_reads_altAlignPos.txt`;	
	`perl $abs_path/create_altAlignment_matrix_file.pl -twoBit $fasta_2bit $bed_name\_Reverse_reads_aligned.sam $pdir > $bed_name\_Reverse_reads_altAlignPos.txt`;
	my %hash;
	open(IN, "$bed_name\_Forward_reads_altAlignPos.txt");
	while(my $line = <IN>){
		chomp $line;
		my ($chr, $pos, $ref, $alt) = split(/\t/, $line);
		$hash{$chr}{$pos}{$ref}{$alt} = 1;
	}
	close(IN);

	open(IN, "$bed_name\_Reverse_reads_altAlignPos.txt");
	while(my $line = <IN>){
		chomp $line;
		my ($chr, $pos, $ref, $alt) = split(/\t/, $line);
		$hash{$chr}{$pos}{$ref}{$alt} = 1;
	}
	close(IN);

	open(OUT, ">$bed_name.blacklist");

	foreach my $c (sort keys %hash){
		foreach my $p (sort {$a <=> $b} keys %{$hash{$c}}){
			foreach my $ref (sort keys %{$hash{$c}{$p}}){
				foreach my $alt (sort keys %{$hash{$c}{$p}{$ref}}){
					print OUT "$c\t$p\t$ref\t$alt\n";
				}
			}
		}
	}
	close(OUT);

	`rm $bed_name.fa`;
	`rm $bed_name\_Forward_reads.fastq`;
	`rm $bed_name\_forward.sai`;
	`rm $bed_name\_Forward_reads_aligned.sam`;
	`rm $bed_name\_Forward_reads_altAlignPos.txt`;
	`rm $bed_name\_Reverse_reads.fastq`;
	`rm $bed_name\_reverse.sai`;
	`rm $bed_name\_Reverse_reads_aligned.sam`;
	`rm $bed_name\_Reverse_reads_altAlignPos.txt`;

	return();
}




sub get_sub_type($$){
	my ($ref, $alt) = @_;
	my $type;
	
	if($ref eq "A"){
		if($alt eq "T"){
			$type = "ATTA";
		}elsif($alt eq "G"){
			$type = "ATGC";
		}else{
			$type = "ATCG";
		}
	}elsif($ref eq "T"){
		if($alt eq "A"){
			$type = "ATTA";
		}elsif($alt eq "G"){
			$type = "ATCG";
		}else{
			$type = "ATGC";
		}		
	}elsif($ref eq "C"){
		if($alt eq "A"){
			$type = "CGAT";
		}elsif($alt eq "G"){
			$type = "CGGC";
		}else{
			$type = "CGTA";
		}
	}else{
		if($alt eq "A"){
			$type = "CGTA";
		}elsif($alt eq "C"){
			$type = "CGGC";
		}else{
			$type = "CGAT";
		}		
	}
	
	return $type;
}



sub mean_and_stdev(@){
	my @vals = @_;
	
	if(not @vals){
		return(0,0);
	}
	
	my $total = 0;
	foreach (@vals){ $total += $_; }
	my $mean = $total/($#vals + 1);
	my $sqtot = 0;
	foreach (@vals){ $sqtot += ($mean - $_) ** 2; }
	my $std = ($sqtot/($#vals)) ** 0.5;
	return($mean, $std);	
}



sub run_calcErrorRates($$$$$$$$){
	my ($bed, $dbsnp, $noBlacklist, $blacklist, $pdir, $sample, $BQ, $MQ) = @_;

	my %SNPs = ('A',0,'T',0,'C',0,'G',0);
	my %dbsnp;
	my %intervals;
	my %skip;

	open(BED, $bed);
	while(my $line = <BED>){
		chomp $line;
		my ($chr, $start, $stop, @other) = split(/\t/, $line);
		$intervals{$chr}{$start} = $stop;
	}

	open(DBSNP, $dbsnp);
	while(my $line = <DBSNP>){
		chomp $line;
		next if($line =~ m/^#/);
		my ($chr, $pos, $rsid, $ref, $alt, @other) = split(/\t/, $line);
		if($ref ne "A" and $ref ne "T" and $ref ne "C" and $ref ne "G"){
			#indel
		}elsif(($alt ne "A" and $alt ne "T" and $alt ne "C" and $alt ne "G") and !($alt =~ m/,/)){
			#indel
		}else{
	INTLOOP: foreach my $start (sort {$a <=> $b} keys %{$intervals{$chr}}){
				my $stop = $intervals{$chr}{$start};
				if($pos >= $start and $pos <= $stop){
					$dbsnp{$chr}{$pos} = $alt;
				}
				last INTLOOP if($pos < $start);
			}
		}
	}
	close(DBSNP);

	if(!$noBlacklist){
		open(FILE, $blacklist);
		while(my $line = <FILE>){
			chomp $line;
			my ($chr, $pos, $ref, $alt) = split(/\t/, $line);
			next if($ref eq "-");
			next if($alt eq "-");
			$skip{$chr}{$pos}{$alt} = 1;
		}
		close(FILE);
	}

	my %sub_types;
	my %mixed_error;
	my %mixed_covs;

	open(PVCF, "$pdir\/intermediate/$sample.xpileup");
	LOOP: while(my $line = <PVCF>){
		chomp $line;
		my ($chr, $pos, $ref, $cov, $indels, @rgs) = split(/\t/, $line);

		if(!(exists($dbsnp{$chr}{$pos}))){
			$ref =~ tr/[a-z]/[A-Z]/;
			foreach my $rg_info (@rgs){
				my ($rg, $bases_info, $bq_info, $mq_info, $bp_info) = split(/\s/, $rg_info);
				$bases_info =~ tr/[a-z]/[A-Z]/;
				my @bases = split(//, $bases_info);
				my @bq = split(//, $bq_info);
				my @mq = split(//, $mq_info);
				my @bp = split(/,/, $bp_info);
				my ($samp, $read, $loc) = split(/_/, $rg);
				
				for(my $i = 0; $i <= $#bases; $i++){
					my $base_qual = ord($bq[$i])-33;
					my $mq_qual = ord($mq[$i])-33;

					if($base_qual >= $BQ and $mq_qual >= $MQ){
						if(!(exists($skip{$chr}{$pos}{$bases[$i]}))){
							if($bases[$i] =~ m/[ATCG]/){
								$mixed_error{$read}{$bp[$i]}{get_sub_type($ref, $bases[$i])}++;
								$sub_types{get_sub_type($ref, $bases[$i])}++;
							}else{
								$mixed_covs{$read}{$bp[$i]}{$ref}++;
							}
						}
					}
				}			
			}
		}
	}
	close(PVCF);

	open(MIX, ">$pdir\/intermediate/$sample.errorRates");
		foreach my $read (sort keys %mixed_error){
			foreach my $bp (sort {$a <=> $b} keys %{$mixed_error{$read}}){
				foreach my $tp (sort keys %sub_types){
					my ($ref1, $ref2, @other) = split(//, $tp);
					my $error = 0;
					my $ref1_cov = 0;
					my $ref2_cov = 0;
					$error = $mixed_error{$read}{$bp}{$tp} if(exists($mixed_error{$read}{$bp}{$tp}));
					$ref1_cov = $mixed_covs{$read}{$bp}{$ref1}/3 if(exists($mixed_covs{$read}{$bp}{$ref1}));
					$ref2_cov = $mixed_covs{$read}{$bp}{$ref2}/3 if(exists($mixed_covs{$read}{$bp}{$ref2}));
					if($ref1_cov + $ref2_cov != 0){
						print MIX "$read\t$bp\t$tp\t".$error/($ref1_cov+$ref2_cov+$error)."\t$error\t".($ref1_cov+$ref2_cov+$error)."\n";
					}
				}
			}
		}
	close(MIX);

	return();
	
}







